/*
	Before using on Switch, make sure wired USB connection is enabled in System Settings.
	TO DO
	There is a slight degree tilt of 20 degrees when in a max cardinal direction on left trackpad. Make a rotation function to adjusut.
	Trackpad deadzone and outer limit do not match stick's. Use a trig function to properly map them back to one:one.
	Simplify button remaps.
	
	For OUTDEAD defines, choose the smallest value that the touchpads can read out of all diagonal directions.
*/

#pragma METAINFO("Steam Controller", 1, 0, "DaMu")
//#include <remapper.gph> 
#include <display.gph>

#define SEGTIME				1500
#define SEGMAX				5

#define SENSITIVITY_X		5.0
#define SENSITIVITY_Y		5.0

#define DELTATIME			1600.0

#define DEADZONE_X			0.0
#define DEADZONE_Y			0.0

#define TOUCHTHRESH			45.0

#define DEADZONE_L_X		15.6
#define DEADZONE_L_Y    	15.6
#define RADIAL_DEADZONE_L 	15.6
#define DEADZONE_R_X    	30.0
#define DEADZONE_R_Y    	30.0
#define DEADZONE_D			1.0
#define MINLEFT_X			15.0
#define MINLEFT_Y			15.0
#define OUTDEAD_L_X			58.5
#define OUTDEAD_L_Y			58.5
#define gyroMultiply		2.0
#define leftLeanPoint		-18.0

 
bool leftPress;
//lean left to click Left Stick. LSC defaults to Right Stick Click.
bool leanLeft;
bool rightPress;

uint8 status_a, status_b, protocol_a, protocol_b, device_a, device_b;
uint8 seg = 0;

fix32 trackBuf;

uint8 segDis () {
	status_a = port_status(PORT_USB_A, &protocol_a, &device_a);
	status_b = port_status(PORT_USB_B, &protocol_b, &device_b);
	if((status_a & DIR_INPUT) && (protocol_a == PROTOCOL_STEAM)) {
		return(_S_);
}
	return(_N_);
}

uint8 segDisRepeat (uint8 i) {
	status_a = port_status(PORT_USB_A, &protocol_a, &device_b);
	status_b = port_status(PORT_USB_B, &protocol_b, &device_b);
	const uint8 steamName[5] = {
		_S_, _T_, _E_, _A_, _M_
	},
	noController[5] = {
		_N_, _O_, _C_, _O_, _R_
	};
	if((status_a & DIR_INPUT) && (protocol_a == PROTOCOL_STEAM)) {
		return(steamName[i]);
	}
	return(noController[i]);
}

/*
const uint8 SteamNintendo[43] = {
    RMP_USB_A, 
    BUTTON_1,  BUTTON_2,  BUTTON_3,  BUTTON_14, BUTTON_15, BUTTON_6,  BUTTON_7, 
    BUTTON_8,  BUTTON_9,  BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_5, 
    BUTTON_17, BUTTON_16, BUTTON_4,  BUTTON_18, BUTTON_19, BUTTON_20, BUTTON_21, 
    STICK_1_X, STICK_1_Y, STICK_2_X, STICK_2_Y, 
    STICK_2_X, STICK_2_Y, POINT_2_X, POINT_2_Y, 
    ACCEL_1_X, ACCEL_1_Y, ACCEL_1_Z, ACCEL_2_X, ACCEL_2_Y, ACCEL_2_Z, 
    GYRO_1_X,  GYRO_1_Y,  GYRO_1_Z,
    BUTTON_15,  BUTTON_16,  PADDLE_3,  PADDLE_4
};
 */

init {
//	remapper(SteamNintendo);
//	device_poweroff();
	display_overlay(segDis(), SEGTIME);
	trackBuf =  0.0;
}


main {
	if(mod((fix32)system_time(), (fix32)SEGTIME) == 0.0) {
		display_overlay(segDisRepeat(seg), SEGTIME);
		seg++;
		if(seg >= SEGMAX) {
			seg = 0;
		}
	}

	//is left pad being touched?
	leftPress = isLeftPress();
	fixLeftTrackpad(leftPress);
	//least required touch distance for maximum output
	//outDeadZone(leftPress);	
	rightPress = isRightPress();	
//	use right pad to swipe and turn
	if(mod((fix32)system_time(), (fix32)DELTATIME) == 0.0) {
//		trackBuf = rightPad(rightPress);
	}

	//Steam gyro is 1/2 Switch's
	buffGyro();
	if(get_actual(ACCEL_1_X) < leftLeanPoint) {
		leanLeft = TRUE;
	} else {
		leanLeft = FALSE;
	}
//	leanLeft = (get_val(ACCEL_1_X < leftLeanPoint)) ? TRUE : FALSE;
	extraButtons(leanLeft);
}

void defunct(){
	    if(get_val(BUTTON_8)) {
        static fix32 offset_x;
        static fix32 offset_y;
        if(event_active(BUTTON_8)) {
            offset_x = get_val(ACCEL_1_X);
            offset_y = get_val(ACCEL_1_Y);
        }
        if(abs(get_val(STICK_1_X)) <= DEADZONE_X && abs(get_val(STICK_1_Y)) <= DEADZONE_Y) {
            motion_aiming(offset_x, offset_y);
        }
    }
}

void motion_aiming(fix32 offset_x, fix32 offset_y) {
    static fix32 accel_x, accel_y;
    static fix32 stick_x, stick_y;
    if(accel_x != get_actual(ACCEL_1_X) || accel_y != get_actual(ACCEL_1_Y)) {
        accel_x = get_actual(ACCEL_1_X);
        accel_y = get_actual(ACCEL_1_Y);
        stick_x = (accel_x - offset_x) * SENSITIVITY_X;
        stick_y = (accel_y - offset_y) * SENSITIVITY_Y;
 
        fix32 signal_x = (stick_x < 0.0) ? (stick_x = inv(stick_x), -1.0) : (stick_x > 0.0) ? 1.0 : 0.0;
        fix32 signal_y = (stick_y < 0.0) ? (stick_y = inv(stick_y), -1.0) : (stick_y > 0.0) ? 1.0 : 0.0;
        fix32 angle = atan2(stick_y, stick_x);
 
        stick_x = clamp(((DEADZONE_X * pow(cos(angle), DEADZONE_D)) + stick_x) * signal_x, -100.0, 100.0);
        stick_y = clamp(((DEADZONE_Y * pow(sin(angle), DEADZONE_D)) + stick_y) * signal_y, -100.0, 100.0);
    }
    set_val(STICK_1_X, stick_x);
    set_val(STICK_1_Y, stick_y);
    return;
}

void trackpadTrace() {
	    if(get_val(BUTTON_20)) {
        static fix32 offset_x;
        static fix32 offset_y;
        if(event_active(BUTTON_20)) {
            offset_x = get_actual(POINT_2_X);
            offset_y = get_actual(POINT_2_Y);
        }
				static fix32 track_x = (get_actual(POINT_2_X) - offset_x) * SENSITIVITY_X;
				static fix32 track_y = (get_actual(POINT_2_Y) - offset_y) * SENSITIVITY_Y;
    }
		if(event_release(BUTTON_20)) {
			
		}
}



//If touching left pad, move left stick. Reset to center on release.
bool isLeftPress(){
	if (get_actual(BUTTON_19) > TOUCHTHRESH){
		//ffb_set(FFB_1, 50.0, 5);
		return(TRUE);
	}
	else{
		//ffb_reset();
		set_val(STICK_2_X, 0);
		set_val(STICK_2_Y, 0);
	}
	return(FALSE);
}

bool isRightPress(){
	if (get_val(BUTTON_20)){
//	ffb_set(FFB_2, 50.0, 5);
		return(TRUE);
	}
/*
//Not touching right pad resets right stick output.
		ffb_reset();
		set_val(STICK_1_X, 0);
		set_val(STICK_1_Y, 0);
	}
*/
	return(FALSE);
}

void outDeadZone(bool isLeft) {
	if (isLeft) {
		if(get_actual(POINT_1_X) > DEADZONE_L_X) {
			set_val(STICK_2_X, clamp(get_actual(POINT_1_X)*SCALE, MINLEFT_X, 100.0));
			if(get_actual(POINT_1_X) > OUTDEAD_L_X) {
				set_val(STICK_2_X, 100.0);
			}			
		}
		if(get_actual(POINT_1_Y) > DEADZONE_L_Y) {
			set_val(STICK_2_Y, clamp(get_actual(POINT_1_Y)*SCALE, MINLEFT_Y, 100.0));
			if(get_actual(POINT_1_Y) > OUTDEAD_L_Y) {
				set_val(STICK_2_Y, 100.0);
			}
		}
		if(get_actual(POINT_1_X) < inv(DEADZONE_L_X)) {
			set_val(STICK_2_X, clamp(get_actual(POINT_1_X)*SCALE, -100.0, inv(MINLEFT_X)));
			if(get_actual(POINT_1_X) < inv(OUTDEAD_L_X)) {
				set_val(STICK_2_X, -100.0);
		}
		}
		if(get_actual(POINT_1_Y) < inv(DEADZONE_L_Y)) {
			set_val(STICK_2_Y, clamp(get_actual(POINT_1_Y)*SCALE, -100.0, inv(MINLEFT_Y)));
			if(get_actual(POINT_1_Y) < inv(OUTDEAD_L_Y)) {
				set_val(STICK_2_Y, -100.0);
			}
		}
	}
}

void fixLeftTrackpad(bool left){
	if (left){
		if((get_actual(POINT_1_X) > DEADZONE_L_X) || (get_actual(POINT_1_X) < inv(DEADZONE_L_X)) ) {
			fix32 solvex;
			//if(get_actual(POINT_1_Y) == 0.0) {}
			//ignore Y if there is no Y input
			if(get_actual(POINT_1_X) < 0.0) {
				solvex = max(-100.0, (fix32)((get_actual(POINT_1_X) + DEADZONE_L_X) * 100.0 / OUTDEAD_L_X));
			}
			if(get_actual(POINT_1_X) > 0.0) {
				solvex = min(100.0, (fix32)((get_actual(POINT_1_X) - DEADZONE_L_X) * 100.0 / OUTDEAD_L_X));
			}
			//else
			//potential = 100.0 * sqrt(pow(get_actual(POINT_1_X),2) + pow(get_actual(POINT_1_Y),2))) / (OUTDEAD_L_X - DEADZONE_L_X)
			//solvex = cos(atan2(get_actual(POINT_1_Y), get_actual(POINT_1_X))) * 100.0 / (OUTDEAD_L_X - DEADZONE_L_X)
			set_val(STICK_2_X, solvex);
		}
		if((get_actual(POINT_1_Y) > DEADZONE_L_Y) || (get_actual(POINT_1_Y) < inv(DEADZONE_L_Y)) ) {
			fix32 solvey;
			//if(get_actual(POINT_1_X) == 0.0) {}
			//ignore X if there is no X input
			if(get_actual(POINT_1_Y) < 0.0) {
				solvey = max(-100.0, (fix32)((get_actual(POINT_1_Y) + DEADZONE_L_Y) * 100.0 / OUTDEAD_L_Y));
			}
			else {
				solvey = min(100.0, (fix32)((get_actual(POINT_1_Y) - DEADZONE_L_Y) * 100.0 / OUTDEAD_L_Y));
			}
			//else
			//potential = 100.0 * sqrt(pow(get_actual(POINT_1_X),2) + pow(get_actual(POINT_1_Y),2))) / (OUTDEAD_L_Y - DEADZONE_L_Y)
			//solvey = sin(atan2(get_actual(POINT_1_Y), get_actual(POINT_1_X))) [potential]* 100.0 / (OUTDEAD_L_Y - DEADZONE_L_Y)
			//printf(".1f", solvey)
			set_val(STICK_2_Y, solvey);
		}
	}
}

void buffGyro(){
	set_val(GYRO_1_Z, get_val(GYRO_1_Z) * gyroMultiply);
	set_val(GYRO_1_Y, get_val(GYRO_1_Y) * gyroMultiply);
}

void extraButtons(bool leanLeft) {
	//left Paddle is Accpet
	if(get_val(PADDLE_1)){
		set_val(BUTTON_15, 100.0);
	}
	//right Paddle is Jump
	if(get_val(PADDLE_2)){
		set_val(BUTTON_16, 100.0);
	}
	//right Pad is Jump
	if(get_val(BUTTON_6)){
		set_val(BUTTON_6, 0.0);
		set_val(BUTTON_16, 100.0);
	}
	if(get_val(BUTTON_9) && !leanLeft) {
			set_val(BUTTON_9, 0.0);
			set_val(BUTTON_6, 100.0);
	}
}

fix32 rightPad(bool isRight) {
	if (isRight) {
		//get current position and save
		current = get_actual(POINT_2_X);
		fix32 deltaStick = current - trackBuf;
		printf(".1f", current);
		printf(".1f", trackBuf);
		//compare current with previous
		set_val(STICK_2_X, deltaStick);
	}
	//listen for event_release
	//slowly reset current position to zero
	return(current) ;
}