/*
	Before using on Switch, make sure wired USB connection is enabled in System Settings.
	TO DO
	There is a slight degree tilt of 20 degrees when in a max cardinal direction on left trackpad. Make a rotation function to adjusut.
	Trackpad deadzone and outer limit do not match stick's. Use a trig function to properly map them back to one:one.
	Simplify button remaps.
	
	For OUTDEAD defines, choose the smallest value that the touchpads can read out of all diagonal directions.
*/

#pragma METAINFO("Steam Controller", 1, 0, "DaMu")
//#include <remapper.gph> 
#include <display.gph>

#define SEGTIME				1500
#define SEGMAX				5

#define SENSITIVITY_X		5.0
#define SENSITIVITY_Y		5.0

#define DELTATIME			16.0

#define DEADZONE_X			0.0
#define DEADZONE_Y			0.0

#define TOUCHTHRESH			45.0
#define DECAY						0.1
#define SWIPESCALE			0.9
#define POLLINGNO				14

#define DEADZONE_L_X		6.6
#define DEADZONE_L_Y    	6.6
#define RADIAL_DEADZONE_L  5.6
#define DEADZONE_R_X    	30.0
#define DEADZONE_R_Y    	30.0
#define DEADZONE_D			1.0
#define MINLEFT_X			15.0
#define MINLEFT_Y			15.0
#define OUTDEAD_L_X			57.5
#define OUTDEAD_L_Y			57.5
#define gyroMultiply		2.0
#define leftLeanPoint		-18.0

 
bool leftPress;
//lean left to click Left Stick. LSC defaults to Right Stick Click.
bool leanLeft;
bool rightPress;

uint8 status_a, status_b, protocol_a, protocol_b, device_a, device_b;
uint8 seg = 0;

fix32 trackBuf_strt, trackBuf_new, trackBuf_release, trackBuf_diff;

uint8 segDis () {
	status_a = port_status(PORT_USB_A, &protocol_a, &device_a);
	status_b = port_status(PORT_USB_B, &protocol_b, &device_b);
	if((status_a & DIR_INPUT) && (protocol_a == PROTOCOL_STEAM)) {
		return(_S_);
}
	return(_N_);
}

uint8 segDisRepeat (uint8 i) {
	status_a = port_status(PORT_USB_A, &protocol_a, &device_b);
	status_b = port_status(PORT_USB_B, &protocol_b, &device_b);
	const uint8 steamName[5] = {
		_S_, _T_, _E_, _A_, _M_
	},
	noController[5] = {
		_N_, _O_, _C_, _O_, _R_
	};
	if((status_a & DIR_INPUT) && (protocol_a == PROTOCOL_STEAM)) {
		return(steamName[i]);
	}
	return(noController[i]);
}

init {
//	device_poweroff();
	display_overlay(segDis(), SEGTIME);
	trackBuf_strt =  0.0;
	trackBuf_release =  0.0;
	trackBuf_new =  0.0;
	trackBuf_diff =  trackBuf_release - trackBuf_strt;
}


main {
	if(mod((fix32)system_time(), (fix32)SEGTIME) == 0.0) {
		display_overlay(segDisRepeat(seg), SEGTIME);
		seg++;
		if(seg >= SEGMAX) {
			seg = 0;
		}
	}
	//is left pad being touched?
	leftPress = isLeftPress();
		//rightPress = isRightPress();	
	//least required touch distance for maximum output
	fixLeftTrackpad(leftPress);
//	use right pad to swipe and turn
	trackBuf_diff = getSwipeDifference();
	set_val(STICK_1_X, trackBuf_diff);
	if(is_release(BUTTON_20)){
//if(is_release(BUTTON_20) && (mod((fix32)system_time(), (fix32)POLLINGNO) == 0.0)) {		
		trackBuf_diff = (trackBuf_diff > 0.0) ? trackBuf_diff - DECAY : trackBuf_diff + DECAY;
	}
	//left track pad overrides stick
	//Steam gyro is 1/2 Switch's
	buffGyro();
	leanLeft = (get_val(ACCEL_1_X) < leftLeanPoint) ? TRUE : FALSE;
	extraButtons(leanLeft);
}

//If touching left pad, move left stick. Reset to center on release.
bool isLeftPress(){
	if (get_actual(BUTTON_19) > TOUCHTHRESH){
		//ffb_set(FFB_1, 50.0, 5);
		return(TRUE);
	}
	else{
		//ffb_reset();
		set_val(STICK_2_X, 0);
		set_val(STICK_2_Y, 0);
	}
	return(FALSE);
}

bool isRightPress(){
	if (get_val(BUTTON_20)){
//	ffb_set(FFB_2, 50.0, 5);
		return(TRUE);
	}
/*
//Not touching right pad resets right stick output.
		ffb_reset();
		set_val(STICK_1_X, 0);
		set_val(STICK_1_Y, 0);
	}
*/
	return(FALSE);
}

/*
void outDeadZone(bool isLeft) {
	if (isLeft) {
		if(get_actual(POINT_1_X) > DEADZONE_L_X) {
			set_val(STICK_2_X, clamp(get_actual(POINT_1_X)*SCALE, MINLEFT_X, 100.0));
			if(get_actual(POINT_1_X) > OUTDEAD_L_X) {
				set_val(STICK_2_X, 100.0);
			}			
		}
		if(get_actual(POINT_1_Y) > DEADZONE_L_Y) {
			set_val(STICK_2_Y, clamp(get_actual(POINT_1_Y)*SCALE, MINLEFT_Y, 100.0));
			if(get_actual(POINT_1_Y) > OUTDEAD_L_Y) {
				set_val(STICK_2_Y, 100.0);
			}
		}
		if(get_actual(POINT_1_X) < inv(DEADZONE_L_X)) {
			set_val(STICK_2_X, clamp(get_actual(POINT_1_X)*SCALE, -100.0, inv(MINLEFT_X)));
			if(get_actual(POINT_1_X) < inv(OUTDEAD_L_X)) {
				set_val(STICK_2_X, -100.0);
		}
		}
		if(get_actual(POINT_1_Y) < inv(DEADZONE_L_Y)) {
			set_val(STICK_2_Y, clamp(get_actual(POINT_1_Y)*SCALE, -100.0, inv(MINLEFT_Y)));
			if(get_actual(POINT_1_Y) < inv(OUTDEAD_L_Y)) {
				set_val(STICK_2_Y, -100.0);
			}
		}
	}
}
*/
void fixLeftTrackpad(bool left){
	fix32 potential;
	if (left){
		if((get_actual(POINT_1_X) > RADIAL_DEADZONE_L) || (get_actual(POINT_1_X) < inv(RADIAL_DEADZONE_L)) ) {
			fix32 solvex;
			if((get_actual(POINT_1_Y) < DEADZONE_L_Y) || (get_actual(POINT_1_Y) > inv(DEADZONE_L_Y))) {
				//ignore Y if there is no Y input
				if(get_actual(POINT_1_X) < 0.0) {
					solvex = max(-100.0, (fix32)((get_actual(POINT_1_X) + DEADZONE_L_X) * 100.0 / OUTDEAD_L_X));
				}
				if(get_actual(POINT_1_X) > 0.0) {
					solvex = min(100.0, (fix32)((get_actual(POINT_1_X) - DEADZONE_L_X) * 100.0 / OUTDEAD_L_X));
				}
			} else {
					potential = 100.0 * sqrt(pow(get_actual(POINT_1_X),2.0) + pow(get_actual(POINT_1_Y),2.0)) / (OUTDEAD_L_X - DEADZONE_L_X);
					solvex = cos(atan2(get_actual(POINT_1_Y), get_actual(POINT_1_X))) * potential;
			}
			set_val(STICK_2_X, solvex);
		}
		if((get_actual(POINT_1_Y) > RADIAL_DEADZONE_L) || (get_actual(POINT_1_Y) < inv(RADIAL_DEADZONE_L)) ) {
			fix32 solvey;
			if((get_actual(POINT_1_X) < DEADZONE_L_X) || (get_actual(POINT_1_X) > inv(DEADZONE_L_X))) {
				//ignore X if there is no X input
				if(get_actual(POINT_1_Y) < 0.0) {
					solvey = max(-100.0, (fix32)((get_actual(POINT_1_Y) + DEADZONE_L_Y) * 100.0 / OUTDEAD_L_Y));
				}
				else {
					solvey = min(100.0, (fix32)((get_actual(POINT_1_Y) - DEADZONE_L_Y) * 100.0 / OUTDEAD_L_Y));
				}
			} else {
				potential = 100.0 * sqrt(pow(get_actual(POINT_1_X),2.0) + pow(get_actual(POINT_1_Y),2.0)) / (OUTDEAD_L_Y - DEADZONE_L_Y);
				solvey = sin(atan2(get_actual(POINT_1_Y), get_actual(POINT_1_X))) * potential;
			}
			set_val(STICK_2_Y, solvey);
		}
	}
}

void buffGyro(){
	set_val(GYRO_1_Z, get_val(GYRO_1_Z) * gyroMultiply);
	set_val(GYRO_1_Y, get_val(GYRO_1_Y) * gyroMultiply);
}

void extraButtons(bool leanLeft) {
	//left Paddle is Accept
	if(get_val(PADDLE_1)){
		set_val(BUTTON_15, 100.0);
	}
	//right Paddle is Jump
	if(get_val(PADDLE_2)){
		set_val(BUTTON_16, 100.0);
	}
	//right Pad is Jump
	if(get_val(BUTTON_6)){
		set_val(BUTTON_6, 0.0);
		set_val(BUTTON_16, 100.0);
	}
	if(get_val(BUTTON_9) && !leanLeft) {
			set_val(BUTTON_9, 0.0);
			set_val(BUTTON_6, 100.0);
	}
}

fix32 getSwipeDifference() {
	if (event_active(BUTTON_20)) {
		trackBuf_strt = get_actual(POINT_2_X);
		printf("test");
		return(0.0);
	}
	/*
	if(check_active(BUTTON_20, POLLINGNO)) {
		trackBuf_strt = get_prev(POINT_2_X);
		trackBuf_new = get_actual(POINT_2_X);
		trackBuf_diff = (trackBuf_new - trackBuf_strt) * SWIPESCALE;
		printf("%.1f", trackBuf_diff);
	}
	*/
	if (event_release(BUTTON_20)) {
		trackBuf_release = get_prev(POINT_2_X);
		trackBuf_diff = (trackBuf_release - trackBuf_strt) * SWIPESCALE;
		printf("release");
	}
	return(clamp(trackBuf_diff, -100.0, 100.0));
}